<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Base Class - Visual Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1 {
            color: #333;
            margin-top: 0;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2 {
            color: #555;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .description {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .canvas-container {
            margin: 20px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            display: inline-block;
            background: #fafafa;
        }

        canvas {
            display: block;
            border-radius: 3px;
        }

        .info {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 14px;
        }

        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: scale(0.98);
        }

        .test-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .test-status.pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .test-status.fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .coords {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Panel Base Class - Visual Test</h1>

        <div class="description">
            <strong>Purpose:</strong> This page provides visual tests for the Panel base class.
            It demonstrates coordinate conversion, bounds checking, mouse interactions, and
            rendering capabilities through concrete examples.
        </div>

        <h2>Test 1: Simple Mock Panel</h2>
        <div class="info">
            This panel demonstrates basic rendering and coordinate systems. The panel is drawn
            with a gradient background and grid lines. Try moving your mouse over it or clicking
            to see coordinate conversion in action.
        </div>

        <div class="canvas-container">
            <canvas id="testCanvas1" width="500" height="400"></canvas>
        </div>

        <div class="coords" id="coordDisplay1">
            Move mouse over canvas to see coordinates...
        </div>

        <h2>Test 2: Multiple Panels (Layout)</h2>
        <div class="info">
            This test shows multiple panels arranged on a single canvas, demonstrating how
            panels can be positioned and scaled independently.
        </div>

        <div class="canvas-container">
            <canvas id="testCanvas2" width="600" height="300"></canvas>
        </div>

        <div class="coords" id="coordDisplay2">
            Move mouse over canvas to see which panel is active...
        </div>

        <h2>Test 3: Interactive Panel</h2>
        <div class="info">
            Click on the canvas to add colored dots. This demonstrates click handling
            and tooltip functionality.
        </div>

        <div class="canvas-container">
            <canvas id="testCanvas3" width="400" height="400"></canvas>
        </div>

        <div class="coords" id="coordDisplay3">
            Click on canvas to add dots. Hover to see tooltip.
        </div>

        <div class="controls">
            <button onclick="clearDots()">Clear Dots</button>
            <button onclick="runTests()">Run All Tests</button>
        </div>

        <div id="testResults"></div>
    </div>

    <script type="module">
        import { Panel } from '../js/visualization/core/Panel.js';
        import { TooltipInfo } from '../js/visualization/core/TooltipInfo.js';

        // ===================================================================
        // Test 1: Simple Mock Panel
        // ===================================================================

        class SimpleMockPanel extends Panel {
            render(ctx, simulation, time) {
                // Draw gradient background
                const gradient = ctx.createLinearGradient(
                    this.bounds.x, this.bounds.y,
                    this.bounds.x + this.bounds.width,
                    this.bounds.y + this.bounds.height
                );
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');

                ctx.fillStyle = gradient;
                ctx.fillRect(this.bounds.x, this.bounds.y,
                            this.bounds.width, this.bounds.height);

                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                const gridSize = 50;
                for (let i = 0; i <= this.bounds.width; i += gridSize) {
                    const canvas = this.localToCanvas(i, 0);
                    ctx.beginPath();
                    ctx.moveTo(canvas.x, this.bounds.y);
                    ctx.lineTo(canvas.x, this.bounds.y + this.bounds.height);
                    ctx.stroke();
                }

                for (let i = 0; i <= this.bounds.height; i += gridSize) {
                    const canvas = this.localToCanvas(0, i);
                    ctx.beginPath();
                    ctx.moveTo(this.bounds.x, canvas.y);
                    ctx.lineTo(this.bounds.x + this.bounds.width, canvas.y);
                    ctx.stroke();
                }

                // Draw border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.strokeRect(this.bounds.x, this.bounds.y,
                              this.bounds.width, this.bounds.height);

                // Draw label
                ctx.fillStyle = 'white';
                ctx.font = '20px sans-serif';
                ctx.fillText(this.name, this.bounds.x + 10, this.bounds.y + 30);

                // Draw origin marker
                const origin = this.localToCanvas(0, 0);
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillText('(0,0)', origin.x + 10, origin.y - 10);
            }

            handleMouseMove(canvasX, canvasY, simulation) {
                const local = this.canvasToLocal(canvasX, canvasY);
                return new TooltipInfo(
                    {
                        canvas: `(${canvasX.toFixed(0)}, ${canvasY.toFixed(0)})`,
                        local: `(${local.x.toFixed(0)}, ${local.y.toFixed(0)})`
                    },
                    canvasX, canvasY
                );
            }
        }

        // Setup Test 1
        const canvas1 = document.getElementById('testCanvas1');
        const ctx1 = canvas1.getContext('2d');
        const panel1 = new SimpleMockPanel('Simple Panel', {
            x: 0, y: 0, width: 500, height: 400
        });

        function render1() {
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            panel1.render(ctx1, null, 0);
        }

        canvas1.addEventListener('mousemove', (e) => {
            const rect = canvas1.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const tooltip = panel1.handleMouseMove(x, y, null);
            if (tooltip) {
                document.getElementById('coordDisplay1').innerHTML = `
                    <strong>Canvas:</strong> ${tooltip.data.canvas} &nbsp;|&nbsp;
                    <strong>Local:</strong> ${tooltip.data.local}
                `;
            }
        });

        render1();

        // ===================================================================
        // Test 2: Multiple Panels
        // ===================================================================

        const canvas2 = document.getElementById('testCanvas2');
        const ctx2 = canvas2.getContext('2d');

        const panels2 = [
            new SimpleMockPanel('Panel A', { x: 10, y: 10, width: 180, height: 280 }),
            new SimpleMockPanel('Panel B', { x: 210, y: 10, width: 180, height: 130 }),
            new SimpleMockPanel('Panel C', { x: 210, y: 160, width: 180, height: 130 }),
            new SimpleMockPanel('Panel D', { x: 410, y: 10, width: 180, height: 280 })
        ];

        function render2() {
            ctx2.fillStyle = '#f0f0f0';
            ctx2.fillRect(0, 0, canvas2.width, canvas2.height);

            for (const panel of panels2) {
                panel.render(ctx2, null, 0);
            }
        }

        canvas2.addEventListener('mousemove', (e) => {
            const rect = canvas2.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let activePanel = null;
            for (const panel of panels2) {
                if (panel.containsPoint(x, y)) {
                    activePanel = panel;
                    break;
                }
            }

            if (activePanel) {
                const tooltip = activePanel.handleMouseMove(x, y, null);
                document.getElementById('coordDisplay2').innerHTML = `
                    <strong>Active Panel:</strong> <span class="highlight">${activePanel.name}</span> &nbsp;|&nbsp;
                    <strong>Canvas:</strong> ${tooltip.data.canvas} &nbsp;|&nbsp;
                    <strong>Local:</strong> ${tooltip.data.local}
                `;
            } else {
                document.getElementById('coordDisplay2').innerHTML =
                    'Mouse outside all panels';
            }
        });

        render2();

        // ===================================================================
        // Test 3: Interactive Panel
        // ===================================================================

        class InteractivePanel extends Panel {
            constructor(name, bounds) {
                super(name, bounds);
                this.dots = [];
            }

            render(ctx, simulation, time) {
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(this.bounds.x, this.bounds.y,
                            this.bounds.width, this.bounds.height);

                // Draw border
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.bounds.x, this.bounds.y,
                              this.bounds.width, this.bounds.height);

                // Draw crosshair at center
                const center = this.localToCanvas(
                    this.bounds.width / 2,
                    this.bounds.height / 2
                );
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(this.bounds.x, center.y);
                ctx.lineTo(this.bounds.x + this.bounds.width, center.y);
                ctx.moveTo(center.x, this.bounds.y);
                ctx.lineTo(center.x, this.bounds.y + this.bounds.height);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw dots
                for (const dot of this.dots) {
                    const canvas = this.localToCanvas(dot.x, dot.y);
                    ctx.fillStyle = dot.color;
                    ctx.beginPath();
                    ctx.arc(canvas.x, canvas.y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw instructions
                ctx.fillStyle = '#666';
                ctx.font = '14px sans-serif';
                ctx.fillText('Click to add colored dots',
                            this.bounds.x + 10, this.bounds.y + 25);
            }

            handleClick(canvasX, canvasY, simulation) {
                const local = this.canvasToLocal(canvasX, canvasY);

                // Random color
                const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b'];
                const color = colors[Math.floor(Math.random() * colors.length)];

                this.dots.push({ x: local.x, y: local.y, color });
                return true;
            }

            handleMouseMove(canvasX, canvasY, simulation) {
                const local = this.canvasToLocal(canvasX, canvasY);
                return new TooltipInfo(
                    {
                        message: 'Click to add a dot',
                        position: `(${local.x.toFixed(0)}, ${local.y.toFixed(0)})`,
                        dotCount: this.dots.length
                    },
                    canvasX, canvasY
                );
            }

            clearDots() {
                this.dots = [];
            }
        }

        const canvas3 = document.getElementById('testCanvas3');
        const ctx3 = canvas3.getContext('2d');
        const panel3 = new InteractivePanel('Interactive Panel', {
            x: 0, y: 0, width: 400, height: 400
        });

        function render3() {
            ctx3.clearRect(0, 0, canvas3.width, canvas3.height);
            panel3.render(ctx3, null, 0);
        }

        canvas3.addEventListener('click', (e) => {
            const rect = canvas3.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (panel3.containsPoint(x, y)) {
                panel3.handleClick(x, y, null);
                render3();
            }
        });

        canvas3.addEventListener('mousemove', (e) => {
            const rect = canvas3.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const tooltip = panel3.handleMouseMove(x, y, null);
            if (tooltip) {
                document.getElementById('coordDisplay3').innerHTML = `
                    <strong>${tooltip.data.message}</strong> &nbsp;|&nbsp;
                    <strong>Position:</strong> ${tooltip.data.position} &nbsp;|&nbsp;
                    <strong>Dots:</strong> ${tooltip.data.dotCount}
                `;
            }
        });

        render3();

        // ===================================================================
        // Global functions
        // ===================================================================

        window.clearDots = function() {
            panel3.clearDots();
            render3();
        };

        window.runTests = function() {
            const results = document.getElementById('testResults');
            let html = '<h2>Automated Test Results</h2>';
            let passed = 0;
            let failed = 0;

            const tests = [
                {
                    name: 'Panel constructor validation',
                    fn: () => {
                        try {
                            new SimpleMockPanel('Test', { x: 0, y: 0, width: -10, height: 100 });
                            return false;
                        } catch (e) {
                            return e.message.includes('must be positive');
                        }
                    }
                },
                {
                    name: 'Coordinate conversion round-trip',
                    fn: () => {
                        const p = new SimpleMockPanel('Test', { x: 100, y: 50, width: 200, height: 150 });
                        const local = p.canvasToLocal(150, 100);
                        const canvas = p.localToCanvas(local.x, local.y);
                        return canvas.x === 150 && canvas.y === 100;
                    }
                },
                {
                    name: 'containsPoint boundary checking',
                    fn: () => {
                        const p = new SimpleMockPanel('Test', { x: 100, y: 100, width: 100, height: 100 });
                        return p.containsPoint(150, 150) &&
                               !p.containsPoint(99, 150) &&
                               !p.containsPoint(200, 150);
                    }
                },
                {
                    name: 'updateBounds updates correctly',
                    fn: () => {
                        const p = new SimpleMockPanel('Test', { x: 0, y: 0, width: 100, height: 100 });
                        p.updateBounds({ x: 50, y: 75, width: 200, height: 300 });
                        return p.bounds.x === 50 && p.bounds.y === 75 &&
                               p.bounds.width === 200 && p.bounds.height === 300;
                    }
                },
                {
                    name: 'handleClick returns boolean',
                    fn: () => {
                        const result = panel3.handleClick(50, 50, null);
                        return typeof result === 'boolean';
                    }
                },
                {
                    name: 'handleMouseMove returns TooltipInfo',
                    fn: () => {
                        const result = panel1.handleMouseMove(50, 50, null);
                        return result instanceof TooltipInfo;
                    }
                }
            ];

            for (const test of tests) {
                try {
                    const result = test.fn();
                    if (result) {
                        html += `<div class="info" style="background: #d4edda; color: #155724;">✓ ${test.name}</div>`;
                        passed++;
                    } else {
                        html += `<div class="info" style="background: #f8d7da; color: #721c24;">✗ ${test.name} - returned false</div>`;
                        failed++;
                    }
                } catch (e) {
                    html += `<div class="info" style="background: #f8d7da; color: #721c24;">✗ ${test.name} - ${e.message}</div>`;
                    failed++;
                }
            }

            html += `<div class="test-status ${failed === 0 ? 'pass' : 'fail'}">
                ${passed} passed, ${failed} failed
            </div>`;

            results.innerHTML = html;
        };
    </script>
</body>
</html>
