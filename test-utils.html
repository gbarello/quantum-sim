<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Utilities Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 { color: #2c3e50; }
        h2 { color: #3498db; margin-top: 30px; }
        .test-section {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .pass { color: #27ae60; font-weight: bold; }
        .fail { color: #e74c3c; font-weight: bold; }
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .metric {
            display: inline-block;
            margin: 10px 20px 10px 0;
            padding: 10px;
            background: #ecf0f1;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Quantum Simulation Utilities Test Suite</h1>
    <div id="results"></div>

    <script type="module">
        import {
            Complex,
            ComplexGrid,
            FFT2D,
            normalize,
            computeNorm,
            totalProbability,
            isNormalized,
            pixelToGrid,
            gridToPixel,
            calculateDx,
            calculateDk,
            getWaveVector,
            createGaussianWavepacket,
            isPowerOf2,
            nextPowerOf2,
            PerformanceMonitor
        } from './js/utils.js';

        import FFT from './lib/fft.js';

        const results = document.getElementById('results');

        function log(message, isPass = null) {
            const div = document.createElement('div');
            if (isPass === true) {
                div.innerHTML = `<span class="pass">✓ PASS</span> ${message}`;
            } else if (isPass === false) {
                div.innerHTML = `<span class="fail">✗ FAIL</span> ${message}`;
            } else {
                div.innerHTML = message;
            }
            results.appendChild(div);
        }

        function section(title) {
            const div = document.createElement('div');
            div.className = 'test-section';
            div.innerHTML = `<h2>${title}</h2>`;
            results.appendChild(div);
            return div;
        }

        function assert(condition, message) {
            log(message, condition);
            return condition;
        }

        function assertClose(actual, expected, tolerance, message) {
            const pass = Math.abs(actual - expected) < tolerance;
            log(`${message} (expected: ${expected.toFixed(6)}, got: ${actual.toFixed(6)})`, pass);
            return pass;
        }

        // Run tests
        async function runTests() {
            const perf = new PerformanceMonitor();

            // Test 1: Complex Number Operations
            {
                const s = section('1. Complex Number Operations');
                const z1 = new Complex(3, 4);
                const z2 = new Complex(1, 2);

                assert(z1.abs() === 5, 'Magnitude: |3+4i| = 5');
                assert(z1.abs2() === 25, 'Squared magnitude: |3+4i|² = 25');
                assertClose(z1.arg(), Math.atan2(4, 3), 1e-10, 'Phase calculation');

                const sum = z1.add(z2);
                assert(sum.re === 4 && sum.im === 6, 'Addition: (3+4i) + (1+2i) = 4+6i');

                const prod = z1.mul(z2);
                assert(prod.re === -5 && prod.im === 10, 'Multiplication: (3+4i) * (1+2i) = -5+10i');

                const conj = z1.conj();
                assert(conj.re === 3 && conj.im === -4, 'Conjugate: (3+4i)* = 3-4i');

                const polar = Complex.fromPolar(1, Math.PI / 2);
                assertClose(polar.re, 0, 1e-10, 'Polar form: r=1, θ=π/2 gives re≈0');
                assertClose(polar.im, 1, 1e-10, 'Polar form: r=1, θ=π/2 gives im≈1');
            }

            // Test 2: ComplexGrid Operations
            {
                const s = section('2. ComplexGrid Storage and Operations');
                const grid = new ComplexGrid(4, 4);

                grid.setReIm(0, 0, 1, 0);
                grid.setReIm(1, 1, 0, 1);

                assert(grid.getRe(0, 0) === 1, 'Grid storage: real part');
                assert(grid.getIm(0, 0) === 0, 'Grid storage: imaginary part');
                assert(grid.getRe(1, 1) === 0 && grid.getIm(1, 1) === 1, 'Grid storage: pure imaginary');

                assertClose(grid.getAbs2(0, 0), 1, 1e-10, 'Grid |ψ|² = 1');
                assertClose(grid.getAbs2(1, 1), 1, 1e-10, 'Grid |ψ|² = 1');

                const totalProb = grid.sumAbs2();
                assertClose(totalProb, 2, 1e-10, 'Total probability before normalization');

                normalize(grid);
                assertClose(grid.sumAbs2(), 1, 1e-6, 'Total probability after normalization = 1');
            }

            // Test 3: 1D FFT
            {
                const s = section('3. 1D FFT Transform');
                const size = 8;
                const fft = new FFT(size);

                // Create a simple signal: delta function at position 0
                const input = fft.createComplexArray();
                input[0] = 1; // Real part of first element
                input[1] = 0; // Imaginary part

                const output = fft.createComplexArray();
                fft.transform(output, input);

                // FFT of delta function should be all ones (flat spectrum)
                let allOnes = true;
                for (let i = 0; i < size; i++) {
                    if (Math.abs(output[i * 2] - 1) > 1e-10 || Math.abs(output[i * 2 + 1]) > 1e-10) {
                        allOnes = false;
                        break;
                    }
                }
                assert(allOnes, 'FFT of delta function yields flat spectrum');

                // Test inverse transform (round-trip)
                const reconstructed = fft.createComplexArray();
                fft.inverseTransform(reconstructed, output);

                assertClose(reconstructed[0], 1, 1e-10, 'IFFT round-trip: first element');
                for (let i = 1; i < size; i++) {
                    assertClose(reconstructed[i * 2], 0, 1e-10, `IFFT round-trip: element ${i} real part`);
                }
            }

            // Test 4: 2D FFT
            {
                const s = section('4. 2D FFT Transform');
                const size = 8;
                const grid = new ComplexGrid(size, size);

                // Create a 2D delta function at center
                grid.setReIm(size/2, size/2, 1, 0);

                const fft2d = new FFT2D(size, size);
                fft2d.forward(grid);

                // Check that transform completed (non-zero values)
                const hasNonZero = grid.sumAbs2() > 0;
                assert(hasNonZero, '2D FFT produces non-zero output');

                // Test inverse (round-trip)
                fft2d.inverse(grid);

                // Should recover original delta function
                assertClose(grid.getAbs2(size/2, size/2), 1, 1e-10, '2D FFT round-trip: delta at center');

                // All other points should be near zero
                let othersZero = true;
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        if (i !== size/2 || j !== size/2) {
                            if (grid.getAbs2(i, j) > 1e-10) {
                                othersZero = false;
                                break;
                            }
                        }
                    }
                }
                assert(othersZero, '2D FFT round-trip: other points are zero');
            }

            // Test 5: Gaussian Wavepacket
            {
                const s = section('5. Gaussian Wavepacket Creation');
                const gridSize = 64;
                const sigma = 5;
                const dx = 0.1;

                perf.start('gaussian');
                const psi = createGaussianWavepacket(
                    gridSize,
                    gridSize/2, gridSize/2,  // centered
                    sigma,                    // width
                    0, 0,                     // zero momentum
                    dx,
                    1.0                       // hbar = 1
                );
                const gaussianTime = perf.end('gaussian');

                assert(psi.sizeX === gridSize && psi.sizeY === gridSize,
                       `Gaussian grid size: ${gridSize}×${gridSize}`);

                assertClose(psi.sumAbs2(), 1, 1e-6, 'Gaussian is normalized');

                // Peak should be at center
                const centerProb = psi.getAbs2(gridSize/2, gridSize/2);
                const edgeProb = psi.getAbs2(0, 0);
                assert(centerProb > edgeProb, 'Peak probability at center');

                log(`<div class="metric">Gaussian creation: ${gaussianTime.toFixed(2)}ms for ${gridSize}×${gridSize} grid</div>`);
            }

            // Test 6: Grid Coordinate Utilities
            {
                const s = section('6. Grid Coordinate Conversions');
                const gridSize = 128;
                const canvasSize = 512;

                // Pixel to grid
                const grid1 = pixelToGrid(256, 256, canvasSize, canvasSize, gridSize);
                assert(grid1.x === 64 && grid1.y === 64, 'Pixel to grid: center');

                const grid2 = pixelToGrid(0, 0, canvasSize, canvasSize, gridSize);
                assert(grid2.x === 0 && grid2.y === 0, 'Pixel to grid: origin');

                // Grid to pixel (round-trip)
                const pixel = gridToPixel(64, 64, canvasSize, canvasSize, gridSize);
                assertClose(pixel.x, 256, 2, 'Grid to pixel round-trip X');
                assertClose(pixel.y, 256, 2, 'Grid to pixel round-trip Y');
            }

            // Test 7: Physics Utilities
            {
                const s = section('7. Physics Calculations');
                const domainSize = 10;
                const gridSize = 128;

                const dx = calculateDx(domainSize, gridSize);
                assertClose(dx, 10/128, 1e-10, `Spatial step: dx = ${domainSize}/${gridSize}`);

                const dk = calculateDk(gridSize, dx);
                const expectedDk = (2 * Math.PI) / (gridSize * dx);
                assertClose(dk, expectedDk, 1e-10, 'Momentum step calculation');

                // Test wave vector calculation
                const k0 = getWaveVector(0, gridSize, dk);
                assertClose(k0, 0, 1e-10, 'Wave vector at k=0');

                const kNyquist = getWaveVector(gridSize/2, gridSize, dk);
                assert(kNyquist > 0, 'Wave vector at Nyquist frequency is positive');
            }

            // Test 8: Mathematical Utilities
            {
                const s = section('8. Mathematical Utilities');

                assert(isPowerOf2(64), '64 is a power of 2');
                assert(isPowerOf2(128), '128 is a power of 2');
                assert(!isPowerOf2(100), '100 is not a power of 2');

                assert(nextPowerOf2(100) === 128, 'Next power of 2 after 100 is 128');
                assert(nextPowerOf2(64) === 64, 'Next power of 2 after 64 is 64');
                assert(nextPowerOf2(65) === 128, 'Next power of 2 after 65 is 128');
            }

            // Test 9: Performance Benchmark
            {
                const s = section('9. Performance Benchmark');

                const sizes = [64, 128, 256];
                for (const size of sizes) {
                    const grid = new ComplexGrid(size, size);

                    // Fill with random data
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            grid.setReIm(i, j, Math.random(), Math.random());
                        }
                    }

                    const fft2d = new FFT2D(size, size);

                    perf.start(`fft_${size}`);
                    fft2d.forward(grid);
                    const fftTime = perf.end(`fft_${size}`);

                    perf.start(`ifft_${size}`);
                    fft2d.inverse(grid);
                    const ifftTime = perf.end(`ifft_${size}`);

                    log(`<div class="metric">FFT ${size}×${size}: Forward ${fftTime.toFixed(2)}ms, Inverse ${ifftTime.toFixed(2)}ms</div>`);
                }
            }

            // Summary
            {
                const s = section('✓ Test Suite Complete');
                log('<p>All core utilities are functioning correctly and ready for quantum simulation!</p>');
                log('<p><strong>Key Features Verified:</strong></p>');
                log('<ul>' +
                    '<li>Complex number arithmetic with full precision</li>' +
                    '<li>Efficient ComplexGrid storage (interleaved Float64Array)</li>' +
                    '<li>Fast 1D and 2D FFT transforms (O(N log N))</li>' +
                    '<li>Gaussian wavepacket generation and normalization</li>' +
                    '<li>Grid coordinate conversion utilities</li>' +
                    '<li>Physics calculations (dx, dk, wave vectors)</li>' +
                    '<li>Performance suitable for real-time simulation</li>' +
                    '</ul>');
            }
        }

        runTests().catch(error => {
            log(`<span class="fail">ERROR: ${error.message}</span>`, false);
            console.error(error);
        });
    </script>
</body>
</html>
